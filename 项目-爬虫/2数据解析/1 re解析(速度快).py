'''Regular Expression正则表达式'''
'''元字符'''
#.能匹配除\n外的任意字符，一次只能一个字符
#- a-zA-Z0-9  到多少
#\w 匹配数字、字母、下划线
#\W 匹配非数字字母下划线
#\d 匹配数字
#\D 匹配非数字
#\n 匹配一个换行符
#\t 匹配一个制表符
#\s 匹配任意空白符
#\S 匹配非空白符
#^  字符串的开始
#$  字符串的结束
#a|b 匹配a或者b
#()  匹配一个组
#[a-zA-Z0-9]匹配字符组中的字符
#[^……]匹配字符组外的所有字符
'''量词'''
#* 重复0次或更多次,后面不能接数字。
#+ 重复1次或更多次，后面不能接数字。\d+
#? 出现0次或1次
#[n} 重复n次
#{n,}重复n次或更多次
#{n,m}重复n到m次
'''贪婪、惰性'''
#.*  贪婪匹配，尽可能多的匹配。
#.*?  惰性匹配，使用通配符，尽可能少的匹配。
import re解析练习
#findall: 匹配字符串中所有的符合正则的内容，返回的是列表，效率较低
lst=re.findall(r'\d+',"我的电话号码是：10086")
print("findall找到的数据：",lst)

#finditer：匹配字符串中所有符合正则的内容，返回的是迭代器对象，效率较高
it = re.finditer(r'\d+',"我的电话号码是：100100,他的电话是199822")
for i in it:
    print("finditer找到的数据：{}".format(i),i.group())#使用.group从迭代器中取元素

#search：全文匹配，找到一个结果就返回
s=re.search(r'\d+',"我的电话号码是：100100,他的电话是199822")
print("search找到的数据：",s.group())#.group 返回第一个match对象

#match：从头开始匹配，第一个不符合规则则返回None。
r=re.match(r'\d+',"我的电话号码是：100100,他的电话是199822")
#print(r.group())  返回的None

#预加载正则
obj = re.compile(r"\d+")
ret = obj.finditer("我的电话号码是100000")
for i in ret:
    print("预加载compile找到的数据：",i.group())
